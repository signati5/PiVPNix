<!-- templates/dashboard.html -->

{% extends 'base.html' %}

{% block title %}Dashboard - PiVPNix{% endblock %}

{% block styles %}
<style>
/* KPI Cards Styling */
.kpi-card .card-body {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 180px;
}
.kpi-icon {
    font-size: 2.5rem;
    color: var(--bs-primary);
}
.kpi-value {
    font-size: 2.8rem;
    font-weight: 700;
}
.kpi-label {
    font-size: 1.1rem;
    color: var(--bs-secondary-color);
}

/* Chart Container Styling */
.chart-container {
    position: relative;
    height: 300px;
    width: 100%;
}

</style>
{% endblock %}


{% block content %}
<div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
    <h1 class="h2">General Overview</h1>
    <small class="text-secondary" id="last-update-time">Initializing...</small>
</div>

<!-- Row for main KPIs -->
<div class="row g-4 mb-4">
    <!-- The 4 KPI cards -->
    <div class="col-md-6 col-lg-3">
        <div class="card kpi-card text-center h-100 shadow-sm">
            <div class="card-body">
                <div class="kpi-icon mb-2"><i class="bi bi-people-fill"></i></div>
                <div class="kpi-value" id="kpi-total-clients">{{ kpi_data.total_clients }}</div>
                <div class="kpi-label">Total Clients</div>
            </div>
        </div>
    </div>
    <div class="col-md-6 col-lg-3">
        <div class="card kpi-card text-center h-100 shadow-sm">
            <div class="card-body">
                <div class="kpi-icon mb-2"><i class="bi bi-person-check-fill"></i></div>
                <div class="kpi-value" id="kpi-online-clients">{{ kpi_data.online_clients }}</div>
                <div class="kpi-label">Online Clients</div>
            </div>
        </div>
    </div>
    <div class="col-md-6 col-lg-3">
        <div class="card kpi-card text-center h-100 shadow-sm">
            <div class="card-body">
                <div class="kpi-icon mb-2"><i class="bi bi-hdd-stack-fill"></i></div>
                <div class="kpi-value" id="kpi-total-traffic">{{ kpi_data.total_traffic }}</div>
                <div class="kpi-label">Total Traffic</div>
            </div>
        </div>
    </div>
     <div class="col-md-6 col-lg-3">
        <div class="card kpi-card text-center h-100 shadow-sm">
            <div class="card-body">
                <div class="kpi-icon mb-2"><i class="bi bi-toggle-on"></i></div>
                <div class="kpi-value">
                    <span id="kpi-enabled-clients">{{ kpi_data.enabled_clients }}</span> / 
                    <span class="text-secondary" id="kpi-disabled-clients">{{ kpi_data.disabled_clients }}</span>
                </div>
                <div class="kpi-label">Enabled / Disabled</div>
            </div>
        </div>
    </div>
</div>

<!-- Row for Charts -->
<div class="row g-4 mb-4">
    <div class="col-lg-4">
        <div class="card shadow-sm h-100">
            <div class="card-header"><h5 class="mb-0"><i class="bi bi-pie-chart-fill me-2"></i>Client Status</h5></div>
            <div class="card-body d-flex align-items-center justify-content-center">
                <div class="chart-container">
                    <canvas id="status-chart"></canvas>
                </div>
            </div>
        </div>
    </div>
    <div class="col-lg-8">
        <div class="card shadow-sm h-100">
            <div class="card-header"><h5 class="mb-0"><i class="bi bi-hdd-network-fill me-2"></i>Total Traffic (Received vs. Sent)</h5></div>
             <div class="card-body d-flex align-items-center justify-content-center">
                <div class="chart-container">
                    <canvas id="total-traffic-chart"></canvas>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Row for the Live Activity Chart -->
<div class="row g-4 mb-4">
    <div class="col-12">
        <div class="card shadow-sm h-100">
            <div class="card-header"><h5 class="mb-0"><i class="bi bi-graph-up me-2"></i>Live Network Activity (Aggregated)</h5></div>
            <div class="card-body">
                <div class="chart-container" style="height: 250px;">
                    <canvas id="activity-chart"></canvas>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Row for Client Details -->
<div class="row g-4">
    <div class="col-lg-6">
        <div class="card shadow-sm h-100">
            <div class="card-header">
                <h5 class="mb-0"><i class="bi bi-graph-up-arrow me-2"></i>Top 5 Clients by Traffic (Details)</h5>
            </div>
            <div class="card-body">
                <ul class="list-group list-group-flush" id="top-clients-list">
                    <!-- Content generated by JS -->
                </ul>
            </div>
        </div>
    </div>
    <div class="col-lg-6">
        <div class="card shadow-sm h-100">
            <div class="card-header">
                <h5 class="mb-0"><i class="bi bi-clock-history me-2"></i>Recently Connected Clients</h5>
            </div>
            <div class="card-body">
                <ul class="list-group list-group-flush" id="recent-clients-list">
                    <!-- Content generated by JS -->
                </ul>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
document.addEventListener('DOMContentLoaded', function () {
    // --- CONFIGURATION AND INITIAL DATA ---
    const initialData = {{ kpi_data|tojson }};
    const updateIntervalSeconds = {{ update_interval }};

    // --- CHART INSTANCES ---
    // We declare them here to have access to them in the update functions.
    let statusChart, totalTrafficChart, activityChart;

    /**
     * Creates the doughnut chart showing the distribution of client statuses.
     * @param {object} data - An object with status counts (e.g., {online: 5, offline: 2}).
     */
    const createStatusChart = (data) => {
        const ctx = document.getElementById('status-chart').getContext('2d'); 
        const computedStyle = getComputedStyle(document.documentElement);
        // Map status keys to CSS variable colors for dynamic theming.
        const statusColors = {
            online:   computedStyle.getPropertyValue('--bs-success-rgb'),
            caching:  computedStyle.getPropertyValue('--bs-info-rgb'),
            idle:     computedStyle.getPropertyValue('--bs-warning-rgb'),
            offline:  computedStyle.getPropertyValue('--bs-secondary-rgb'),
            disabled: computedStyle.getPropertyValue('--bs-dark-rgb')
        };
        
        statusChart = new Chart(ctx, {
            type: 'doughnut',
            data: {
                labels: Object.keys(data).map(key => statusConfig[key]?.text || key),
                datasets: [{
                    data: Object.values(data),
                    backgroundColor: Object.keys(data).map(key => `rgba(${statusColors[key]}, 0.7)`),
                    borderColor: '#1e1e1e', // Dark border for segment separation
                    borderWidth: 2
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: { legend: { position: 'bottom', labels: { color: '#fff' } } }
            }
        });
    };
    
    /**
     * Creates the doughnut chart showing total received vs. sent traffic.
     * @param {number} received - Total bytes received.
     * @param {number} sent - Total bytes sent.
     */
    const createTotalTrafficChart = (received, sent) => {
        const ctx = document.getElementById('total-traffic-chart').getContext('2d');
        const computedStyle = getComputedStyle(document.documentElement);
        
        totalTrafficChart = new Chart(ctx, {
            type: 'doughnut',
            data: {
                labels: ['Received', 'Sent'],
                datasets: [{
                    data: [received, sent],
                    backgroundColor: [
                        computedStyle.getPropertyValue('--received-traffic').trim(),
                        computedStyle.getPropertyValue('--send-traffic').trim()
                    ],
                    borderColor: '#1e1e1e',
                    borderWidth: 2
                }]
            },
            options: {
                responsive: true, maintainAspectRatio: false,
                plugins: {
                    legend: { position: 'bottom', labels: { color: '#fff' } },
                    // Use a callback to format the tooltip values as human-readable byte sizes.
                    tooltip: { callbacks: { label: (context) => `${context.label}: ${formatBytes(context.raw)}` } }
                }
            }
        });
    };

    /**
     * A custom Chart.js plugin to draw a vertical line (crosshair) that follows the tooltip.
     */
    const crosshairPlugin = {
        id: 'crosshair',
        afterDraw: chart => { 
            if (chart.tooltip?._active?.length) { 
                let x = chart.tooltip._active[0].element.x; 
                let yAxis = chart.scales.y; 
                let ctx = chart.ctx; 
                ctx.save(); 
                ctx.beginPath(); 
                ctx.moveTo(x, yAxis.top); 
                ctx.lineTo(x, yAxis.bottom); 
                ctx.lineWidth = 1; 
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)'; 
                ctx.stroke(); 
                ctx.restore(); 
            } 
        }
    };

    /**
     * Creates the line chart for live network activity.
     * @param {Array<number>} timestamps - Array of UNIX timestamps for the x-axis.
     * @param {Array<number>} receivedData - Array of received bytes for each timestamp.
     * @param {Array<number>} sentData - Array of sent bytes for each timestamp.
     */
    const createActivityChart = (timestamps, receivedData, sentData) => {
        const ctx = document.getElementById('activity-chart').getContext('2d');
        const computedStyle = getComputedStyle(document.documentElement);

        const formattedLabels = (timestamps || []).map(ts => formatTimeFromUnix(ts));

        activityChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: formattedLabels,
                datasets: [
                    { label: 'Received', data: receivedData, borderColor: computedStyle.getPropertyValue('--received-traffic').trim(), backgroundColor: 'rgba(25, 135, 84, 0.2)', fill: true, tension: 0.4 },
                    { label: 'Sent', data: sentData, borderColor: computedStyle.getPropertyValue('--send-traffic').trim(), backgroundColor: 'rgba(13, 110, 253, 0.2)', fill: true, tension: 0.4 }
                ]
            },
            options: {
                responsive: true, 
                maintainAspectRatio: false,
                interaction: { mode: 'index', intersect: false }, // Tooltip shows values for both datasets at a given x-index
                plugins: { 
                    legend: { position: 'top', align: 'end', labels: { color: '#fff' } },
                    tooltip: { 
                        position: 'nearest',
                        callbacks: {
                            // Use the full timestamp for the tooltip title for more detail
                            title: function(context) {
                                const dataIndex = context[0].dataIndex;
                                return (timestamps && timestamps[dataIndex]) ? formatUnixTimestamp(timestamps[dataIndex]) : '';
                            }
                        }
                    }
                },
                scales: {
                    // Setting min: 0 prevents the y-axis from starting below zero, which can be confusing.
                    y: { 
                        min: 0, 
                        ticks: { color: '#ccc', callback: (value) => formatBytes(value, 0) }, 
                        grid: { color: 'rgba(255, 255, 255, 0.1)' } 
                    },
                    x: { grid: { display: false } }
                }
            },
            plugins: [crosshairPlugin] // Register the custom crosshair plugin
        });
    };

    // --- UPDATE FUNCTIONS ---
    /**
     * Updates all dashboard components with new data from the API.
     * @param {object} data - The complete data object from the API.
     */
    const updateDashboard = (data) => {
        // Update KPI card text content
        document.getElementById('kpi-total-clients').innerText = data.total_clients;
        document.getElementById('kpi-online-clients').innerText = data.online_clients;
        document.getElementById('kpi-total-traffic').innerText = data.total_traffic;
        document.getElementById('kpi-enabled-clients').innerText = data.enabled_clients;
        document.getElementById('kpi-disabled-clients').innerText = data.disabled_clients;
        document.getElementById('last-update-time').innerText = `Updated: ${formatUnixTimestamp(data.last_update)}`;

        // Update charts by changing their data and calling .update()
        // 'none' animation prevents flickering during frequent updates.
        if (statusChart) {
            statusChart.data.datasets[0].data = Object.values(data.status_counts);
            statusChart.update('none');
        }
        if (totalTrafficChart) {
            totalTrafficChart.data.datasets[0].data = [data.aggregate_traffic_received, data.aggregate_traffic_sent];
            totalTrafficChart.update('none');
        }
        
        if (activityChart) {
            // Format the new timestamps BEFORE updating the chart to ensure labels are correct.
            activityChart.data.labels = (data.timeseries_labels || []).map(ts => formatTimeFromUnix(ts));
            activityChart.data.datasets[0].data = data.timeseries_received;
            activityChart.data.datasets[1].data = data.timeseries_sent;
            // Also, update the tooltip's title callback to use the new timestamps.
            activityChart.options.plugins.tooltip.callbacks.title = function(context) {
                const dataIndex = context[0].dataIndex;
                return (data.timeseries_labels && data.timeseries_labels[dataIndex]) ? formatUnixTimestamp(data.timeseries_labels[dataIndex]) : '';
            };
            activityChart.update('none');
        }

        // Update the detail lists
        updateList('top-clients-list', data.top_clients, client => `<span><i class="bi bi-person-fill me-2"></i>${client.name}</span><span class="badge bg-primary rounded-pill">${client.total_traffic_formatted}</span>`);
        updateList('recent-clients-list', data.recent_clients, client => `<span><i class="bi bi-person-fill me-2"></i>${client.name}</span><small class="text-secondary">${client.last_seen}</small>`);
    };

    /**
     * A generic function to update the content of a list group.
     * @param {string} listId - The ID of the <ul> element.
     * @param {Array<object>} items - The array of data items to display.
     * @param {Function} formatter - A function that takes an item and returns its HTML string.
     */
    const updateList = (listId, items, formatter) => {
        const listElement = document.getElementById(listId);
        if (!listElement) return;
        let content = '';
        if (items && items.length > 0) {
            content = items.map(item => `<li class="list-group-item d-flex justify-content-between align-items-center">${formatter(item)}</li>`).join('');
        } else {
            content = `<li class="list-group-item text-center text-secondary">No data available.</li>`;
        }
        listElement.innerHTML = content;
    };

    /**
     * Fetches the latest data from the API endpoint and calls the update function.
     */
    const fetchData = async () => {
        try {
            const response = await fetch("{{ url_for('dashboard.api_kpi') }}");
            if (!response.ok) throw new Error(`HTTP Error: ${response.status}`);
            const data = await response.json();
            updateDashboard(data);
        } catch (error) {
            console.error("Failed to update KPI data:", error);
            document.getElementById('last-update-time').innerText = 'Update failed';
        }
    };
    
    // --- INITIALIZATION ---
    // Create the charts with the initial data passed from the server.
    createStatusChart(initialData.status_counts);
    createTotalTrafficChart(initialData.aggregate_traffic_received, initialData.aggregate_traffic_sent);
    createActivityChart(initialData.timeseries_labels, initialData.timeseries_received, initialData.timeseries_sent);

    // Perform an initial update to populate the lists.
    updateDashboard(initialData);
    // Set up a recurring timer to fetch new data periodically.
    setInterval(fetchData, updateIntervalSeconds * 1000);
});
</script>
{% endblock %}